# -*- coding: utf-8 -*-
"""Copy of Part_I:ML_intro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hVTENsBiCBKL8UwAqtntuJCa3C6X2y8o

# Введение в ML

[квиз](https://docs.google.com/forms/d/e/1FAIpQLScUY2sMnfRZATZ0xUfh5DyoWpz0tbKxS--G0WUB9OkemmxxQA/viewform?usp=sf_link)

## Исходные данные

Для начала скопируйте в корень гугл диска (своего) директорию с данными https://drive.google.com/drive/folders/1f0xJzIxfsfI_QbE6VB82W7xkcxTipgkP?usp=sharing

Будем использовать датасет по стоимости страховых услуг - подробнее см. [соревнование на Kaggle](https://www.kaggle.com/mirichoi0218/insurance)
"""

import logging
import os
import shutil 

import numpy as np
from google.colab import drive

RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)  # гарантируем воспроизводимость

logging.basicConfig(format='%(asctime)s : %(levelname)s : %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)
logger.info('Инициализировали логгер')

ROOT_DIR = '/content/drive' 
drive.mount(ROOT_DIR)
logger.info('Подключили диск')

root_data_dir = os.path.join(ROOT_DIR, 'MyDrive', 'hse_nlp_2021')
if not os.path.exists(root_data_dir):
  raise RuntimeError('Отсутствует директория с данными')
else:
  logger.info('Содержимое директории %s: %s', root_data_dir, os.listdir(root_data_dir))

"""Среди файлов находится `insurance.csv` - это и есть данные по стоимости страховки, на примере которых мы познакомимся с основными понятиями ML

Прочитаем файл с помощью бибилиотеки pandas
"""

import os
import pandas as pd

insurance_df = pd.read_csv(os.path.join(root_data_dir, 'insurance.csv'))

insurance_df.head()

"""Наш таргет (целевая переменная) находится в столбце `charges`

Визуализируем переменную с помощью `.scatter`
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from matplotlib import pyplot as plt

# %matplotlib inline

y = insurance_df['charges']

fig, subplot = plt.subplots()
plt.scatter(
    np.arange(len(y)),
    y
)
subplot.set_xlabel('Индекс клиента')
subplot.set_ylabel('Цена')
fig.show()

"""Получается не очень наглядно - попробуем визуализировать с помощью метода `.hist()` который реализован в pandas"""

y.hist()

"""Для каждого объекта построим предсказания с помощью модели линейной регрессии. Воспользуемся как чёрным ящиком питоновским объектом из бибилиотеки [sklearn](https://scikit-learn.org/stable/)

Модели машинного обучения не могут работать с текстом напрямую (вспоминаем лекцию) - а у нас много текстовых полей, их нужно трансформировать в числа - воспользуемся классом `sklearn.preprocessing.LabelEncoder` из библиотеки sklearn

Чтобы преобразовать колонку в текст нужно воспользоватьеся методом [.fit_transform()](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html#sklearn.preprocessing.LabelEncoder.fit_transform)
"""

from sklearn.preprocessing import LabelEncoder

for label in ['sex', 'smoker', 'region']:
  insurance_df[label] = LabelEncoder().fit_transform(insurance_df[label])

insurance_df.head()

insurance_df.region.value_counts() # сбалансированный датасет

insurance_df.region.value_counts(normalize=True) # доли

"""Обучим линейную регрессию - это класс [sklearn.linear_model.LinearRegression](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html)

Что нужно для счастья
* создать объект
* вызвать метод *.fit()*

Загляните в документацию метода [.fit()](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression.fit) который принимает на вход два аргумента

* $X$ - матрица объекты - признаки. Удалите из датафрейма `insurance_df` столбец `charges` и сохраните результат в переменную $X$
* `y` - значение целевой переменной
"""

from sklearn.linear_model import LinearRegression

reg = None  # объект модели линейной регрессии 
#-------- ВАШ КОД ТУТ -------------------
insurance_transformed_df = insurance_df.copy()

X = insurance_df.drop(labels='charges', axis=1)

reg = LinearRegression()
reg.fit(X, y)
logger.info('модель обучена')
#----------------------------------------

"""Добавим к датафрейму столбец `prediction`"""

insurance_df['prediction'] = reg.predict(X)
insurance_df.head()

"""Задача - посчитайте эмпирический риск по формуле 

$$
Q_{\text{emp}}(h) = \frac{1}{N}\sum_{i=1}^{N}L(h(x_i, \theta), y_i)
$$

где $h(\cdot)$ - значение столбца prediction

Для удобства создайте столбец `squared_loss` - там должно храниться значение $L(y,\hat{y})$:

$L(y,\hat{y}) = (y - \hat{y})^2$

Пользоваться можно только функциями pandas

Полученное значение $Q$ округлите с помощью `np.round(Q, decimals=1)`
"""

insurance_df.head()

num_rows = insurance_df.shape[0]
insurance_df['squared_loss'] = np.zeros(num_rows)
#-------- ВАШ КОД ТУТ -------------------
insurance_df['squared_loss'] = (insurance_df['prediction'] - insurance_df['charges']) ** 2
Q = insurance_df['squared_loss'].mean()
np.round(Q, decimals=1)
#----------------------------------------

"""Визуализируем гистограмму остатков линейной регрессии - это разница между истинным и предсказанным значением."""

(insurance_df['prediction'] - y).hist()

"""Кстати, метрику качества необязательно считать вручную - в sklearn реализовано [огромное количество метрик](https://scikit-learn.org/stable/modules/classes.html#regression-metrics) для регрессии (и других задач тоже)

Подробнее о метриках регрессии мы поговорим в дальнейших занятиях

В качестве упражнения посчитайте какую-нибудь метрику - например, MAE - [sklearn.metrics.mean_absolute_error](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_absolute_error.html)
"""

#-------- ВАШ КОД ТУТ -------------------
from sklearn.metrics import mean_absolute_error

mean_absolute_error(y, insurance_df['prediction'])

#----------------------------------------

"""Мы поговорили про фичи, про метрики - можно немного углубиться в модель, что представляет собой линейная регрессия?

Задача *линейной* регресии: восстановить на функцию $h(x_i)$ в виде *линейной комбинации* (т.е. суммы с некоторыми весами *важности*) признаков объекта. Сами признаки называются *предикторами*:,
$$
\forall x_i: h(x) = w_0 + w_1x_i^1 + \ldots + w_nx_i^n = \sum_{j=1}^{n}w_jx_i^j = \overline{x}_i^T\overline{w}
$$

К признаковому пространству добавляется "фиктивный" признак $x_0=1$, "важность" которого сохраняется в коэффициент $w_0$.

То есть "семейство функций" представляет собой всевозможные комбинации $[w_0, w_1 , w_2 , w_3 , w_4 , w_5 , w_6]$ а метод *.fit()* волшебным образом подбирает их так, чтобы получить максимальное качество.

Мера качества $L$ для задачи регрессии - квадрат разности между фактическим значением и прогнозом. ,
$$
L(h(x_i, \theta), y_i) = \left(y_i - h(x_i, \theta)\right)^2 = \left(y_i -  \sum_{j=1}^{n}w_jx_i^j\right)^2
$$
"""

fig, subplot = plt.subplots()
plt.bar(np.arange(len(reg.coef_)), reg.coef_)
subplot.set_xticks(np.arange(len(reg.coef_)))
subplot.set_xticklabels(X.columns.tolist(), rotation=65)
subplot.set_ylabel('w')
fig.show()

"""В качестве финального задания разберёмся как делать валидацию

Нам понадобится функция [sklearn.model_selection.train_test_split](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html)

Функция принимает несколько аргументов

* `X, y` - первые два аргумента, которые нужно засплиттить
* `test_size=0.33` - доля датасета, которая уйдет в тест
* `random_state=RANDOM_SEED`
"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)

"""Обучите модель на X_train, y_train вызвав метод fit"""

validated_reg = None
#-------- ВАШ КОД ТУТ -------------------

validated_reg = LinearRegression()
validated_reg.fit(X_train, y_train)

#----------------------------------------

"""Сделайте предикт на `X_test`, `y_test` - сохраните его в переменную `y_test_predicted`"""

y_test_predicted = np.zeros_like(y_test)
#-------- ВАШ КОД ТУТ -------------------

y_test_predicted = validated_reg.predict(X_test)

#----------------------------------------

"""Посчитайте [sklearn.metrics.mean_squared_error](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error)

* `y_true`
* `y_pred`

Ответ округлите `np.round(mse, decimals=1)`
"""

#-------- ВАШ КОД ТУТ -------------------
from sklearn.metrics import mean_squared_error

mse = mean_squared_error(y_test, y_test_predicted)
np.round(mse, decimals=1)

#----------------------------------------

